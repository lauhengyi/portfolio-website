/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import planeTrajectories from './planeTrajectories';

type GLTFResult = GLTF & {
  nodes: {
    Plane: THREE.Mesh;
  };
};

type planeDetail = {
  planeObject: THREE.Object3D;
  endX: number;
  travelVector: THREE.Vector3;
};

export default function Planes(props: JSX.IntrinsicElements['group']) {
  const { nodes } = useGLTF('models/plane.glb') as GLTFResult;
  const planeDetails = useRef<planeDetail[]>([]);
  const planeRef = useRef<THREE.InstancedMesh>(null!);
  const planeCount = 3;

  function getRandomPlaneDetail(): planeDetail {
    const trajectory =
      planeTrajectories[Math.floor(Math.random() * planeTrajectories.length)];

    // Move and rotate plane to start position
    const planeObject = new THREE.Object3D();
    planeObject.position.set(
      trajectory.startX,
      Math.random() * 10,
      trajectory.startZ,
    );
    planeObject.rotation.set(0, trajectory.rotateY, trajectory.rotateZ);

    const speed = Math.random() * 5 + 10;
    const travelVector = new THREE.Vector3(speed, 0, 0).applyEuler(
      new THREE.Euler(0, trajectory.rotateY, trajectory.rotateZ),
    );

    return {
      planeObject,
      travelVector,
      endX: trajectory.endX,
    };
  }

  for (let i = 0; i < planeCount; i++) {
    planeDetails.current.push(getRandomPlaneDetail());
  }

  useFrame((_, delta) => {
    for (let i = 0; i < planeCount; i++) {
      const { planeObject, travelVector, endX } = planeDetails.current[i];
      planeObject.position.addScaledVector(travelVector, delta);
      planeObject.updateMatrix();
      planeRef.current.setMatrixAt(i, planeObject.matrix);
      if (
        (planeObject.position.x > endX && travelVector.x > 0) ||
        (planeObject.position.x < endX && travelVector.x < 0)
      ) {
        planeDetails.current[i] = getRandomPlaneDetail();
      }
    }
    planeRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <group {...props} dispose={null}>
      <instancedMesh
        ref={planeRef}
        args={[undefined, undefined, planeCount]}
        geometry={nodes.Plane.geometry}
        position={[0, 35, 0]}
      >
        <meshBasicMaterial color="red" />
      </instancedMesh>
    </group>
  );
}

useGLTF.preload('/models/plane.glb');
