/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useEffect, useRef } from 'react';
import { useFrame } from '@react-three/fiber';
import { useGLTF, useTexture } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import planeTrajectories from './planeTrajectories';

type GLTFResult = GLTF & {
  nodes: {
    Plane: THREE.Mesh;
  };
};

type planeDetail = {
  planeObject: THREE.Object3D;
  endX: number;
  travelVector: THREE.Vector3;
};

type iUv = THREE.InstancedBufferAttribute & {
  array: Float32Array;
};

export default function Planes() {
  const { nodes } = useGLTF('models/plane.glb') as GLTFResult;

  // Texture
  const bakedPlaneAtlas = useTexture('textures/bakedPlaneAtlas.jpg');
  bakedPlaneAtlas.flipY = false;

  // const atlasSize = 2;
  const modifyShader = (shader: THREE.Shader) => {
    shader.vertexShader = `
        attribute vec2 iUv;
      varying vec2 instUv;
      ${shader.vertexShader}
    `.replace(
      `#include <begin_vertex>`,
      `#include <begin_vertex>
      	instUv = iUv;
      `,
    );
    shader.fragmentShader = `
    	varying vec2 instUv;
    	${shader.fragmentShader}
    `.replace(
      `#include <map_fragment>`,
      `
      #ifdef USE_MAP
        vec4 sampledDiffuseColor = texture2D( map, instUv + vUv * 0.5 );

        diffuseColor *= sampledDiffuseColor;
      #endif
    `,
    );
  };

  const planeDetails = useRef<planeDetail[]>([]);
  const planeRef =
    useRef<THREE.InstancedMesh<THREE.BufferGeometry, THREE.MeshBasicMaterial>>(
      null,
    );
  const planeCount = 4;

  function getRandomPlaneDetail(index: number): planeDetail {
    const trajectory = planeTrajectories[index];

    // Move and rotate plane to start position
    const planeObject = new THREE.Object3D();
    planeObject.position.set(
      trajectory.startX,
      Math.random() * 11,
      trajectory.startZ,
    );
    planeObject.rotation.set(0, trajectory.rotateY, trajectory.rotateZ);

    const speed = Math.random() * 5 + 10;
    const travelVector = new THREE.Vector3(speed, 0, 0).applyEuler(
      new THREE.Euler(0, trajectory.rotateY, trajectory.rotateZ),
    );

    return {
      planeObject,
      travelVector,
      endX: trajectory.endX,
    };
  }

  const indexToUV = [
    [0, 0],
    [0.5, 0],
    [0, 0.5],
    [0.5, 0.5],
  ];

  useEffect(() => {
    const uvs = [];
    for (let i = 0; i < planeCount; i++) {
      const index = Math.floor(Math.random() * planeTrajectories.length);
      uvs.push(...indexToUV[index]);
      planeDetails.current.push(getRandomPlaneDetail(index));
    }

    nodes.Plane.geometry.setAttribute(
      'iUv',
      new THREE.InstancedBufferAttribute(new Float32Array(uvs), 2),
    );
  }, []);

  useFrame((_, delta) => {
    if (planeDetails.current.length === 0) return;
    if (planeRef.current === null) return;

    for (let i = 0; i < planeCount; i++) {
      const { planeObject, travelVector, endX } = planeDetails.current[i];
      planeObject.position.addScaledVector(travelVector, delta);
      planeObject.updateMatrix();
      planeRef.current.setMatrixAt(i, planeObject.matrix);
      if (
        (planeObject.position.x > endX && travelVector.x > 0) ||
        (planeObject.position.x < endX && travelVector.x < 0)
      ) {
        const index = Math.floor(Math.random() * planeTrajectories.length);
        planeDetails.current[i] = getRandomPlaneDetail(index);
        const currentIUV = nodes.Plane.geometry.attributes.iUv as iUv;
        const newUV = indexToUV[index];
        currentIUV.array[i * 2] = newUV[0];
        currentIUV.array[i * 2 + 1] = newUV[1];
        currentIUV.needsUpdate = true;
      }
    }

    planeRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <group dispose={null} position={[0, 32, 0]}>
      <instancedMesh
        ref={planeRef}
        args={[undefined, undefined, planeCount]}
        geometry={nodes.Plane.geometry}
      >
        <meshBasicMaterial
          map={bakedPlaneAtlas}
          onBeforeCompile={modifyShader}
        />
      </instancedMesh>
    </group>
  );
}

useGLTF.preload('/models/plane.glb');
useTexture.preload('/textures/bakedPlaneAtlas.jpg');
