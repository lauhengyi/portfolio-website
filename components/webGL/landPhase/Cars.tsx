/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useRef, useEffect } from 'react';
import { useGLTF, useTexture } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame } from '@react-three/fiber';
import getRandomAtlasUV from '../../utils/getRandomAtlasUV';
import addUVOffsetBeforeCompile from '../shaders/addUVOffsetBeforeCompile';

type GLTFResult = GLTF & {
  nodes: {
    car: THREE.Mesh;
  };
};

type iUv = THREE.InstancedBufferAttribute & {
  array: Float32Array;
};

export default function Cars() {
  const { nodes } = useGLTF('/models/car.glb') as GLTFResult;
  const bakedCarAtlas = useTexture('/textures/bakedCarAtlas.jpg');
  bakedCarAtlas.flipY = false;

  const atlasSize = 4;

  /*
  / Modifying shader to use atlas
  */
  const modifyShader = addUVOffsetBeforeCompile(atlasSize);

  /*
  / Animating cars
  */
  const carRef = useRef<THREE.InstancedMesh>(null!);
  const carsPerLane = 4;
  const carSpeedMin = 1;
  const carSpeedRange = 1;
  const carDurationMin = 2;
  const carDurationRange = 4;
  const travelDistFromOrigin = 9.5;
  // Initialize car speeds as 0;
  const carRecord = useRef<
    { speed: number; deployTime: number | null; carObject: THREE.Object3D }[]
  >(new Array(carsPerLane * 2));

  useEffect(() => {
    for (let i = 0; i < carsPerLane * 2; i++) {
      carRecord.current[i] = {
        speed: 0,
        deployTime: null,
        carObject: new THREE.Object3D(),
      };
    }

    // Move first cars
    carRecord.current[0].speed = carSpeedMin + Math.random() * carSpeedRange;
    carRecord.current[carsPerLane].speed = -(
      carSpeedMin +
      Math.random() * carSpeedRange
    );
    carRecord.current[1].deployTime =
      carDurationMin + Math.random() * carDurationRange;
    carRecord.current[carsPerLane + 1].deployTime =
      carDurationMin + Math.random() * carDurationRange;

    const uvs = [];
    for (let i = 0; i < carsPerLane; i++) {
      const carObject = carRecord.current[i].carObject;
      carObject.position.set(-travelDistFromOrigin, 0.04, 1.56);
      carObject.updateMatrix();
      uvs.push(...getRandomAtlasUV(atlasSize, true));
      carRef.current.setMatrixAt(i, carObject.matrix);
    }
    for (let i = carsPerLane; i < carsPerLane * 2; i++) {
      const carObject = carRecord.current[i].carObject;
      carObject.position.set(travelDistFromOrigin, 0.04, 1.97);
      carObject.rotation.set(0, Math.PI, 0);
      carObject.updateMatrix();
      uvs.push(...getRandomAtlasUV(atlasSize, false));
      carRef.current.setMatrixAt(i, carObject.matrix);
    }
    carRef.current.instanceMatrix.needsUpdate = true;

    nodes.car.geometry.setAttribute(
      'iUv',
      new THREE.InstancedBufferAttribute(new Float32Array(uvs), 2),
    );
  }, []);

  useFrame(({ clock }, delta) => {
    // Check if carRef and carRecord is initialized
    if (!carRef.current) return;
    if (!carRecord.current[0]) return;

    // Move cars
    for (let i = 0; i < carsPerLane * 2; i++) {
      const carSpeed = carRecord.current[i].speed;
      if (carSpeed === 0) continue;

      const carObject = carRecord.current[i].carObject;
      carObject.position.x += carSpeed * delta;
      if (carObject.position.x > travelDistFromOrigin) {
        carObject.position.x = -travelDistFromOrigin;
        carRecord.current[i].speed = 0;
      } else if (carObject.position.x < -travelDistFromOrigin) {
        carObject.position.x = travelDistFromOrigin;
        carRecord.current[i].speed = 0;
      }
      carObject.updateMatrix();
      carRef.current.setMatrixAt(i, carObject.matrix);
    }

    // Deploy cars
    // Function to handle deployment, returns true if car is deployed
    const handleCarDeployment = (
      index: number,
      isFrontLane: boolean,
    ): boolean => {
      if (
        carRecord.current[index].deployTime && // Make sure car is next to be deployed
        clock.elapsedTime > carRecord.current[index].deployTime! && // Make sure it is time to deploy
        carRecord.current[index].speed === 0 // Make sure car is not already deployed
      ) {
        // Calculate new speed
        // Setting a max speed to prevent the deployed car from overtaking the car in front
        let maxSpeed;

        let carBeforeIndex;
        if (isFrontLane) {
          carBeforeIndex = index === 0 ? carsPerLane - 1 : index - 1;
        } else {
          carBeforeIndex =
            index === carsPerLane ? carsPerLane * 2 - 1 : index - 1;
        }
        const carBefore = carRecord.current[carBeforeIndex];

        if (carBefore.speed === 0) {
          // No car in front, so no speed cap
          maxSpeed = Infinity;
        } else {
          // Calculate time for car infront to reach the end
          const distanceToCarBefore = Math.abs(
            carBefore.carObject.position.x -
              carRecord.current[index].carObject.position.x,
          );
          let distanceLeft = travelDistFromOrigin * 2 - distanceToCarBefore;
          const timeToCatchUp = distanceLeft / Math.abs(carBefore.speed);
          // Added less distance to compensate for length of car
          const additionalSpeed = (distanceToCarBefore - 1.5) / timeToCatchUp;
          maxSpeed = Math.abs(carBefore.speed) + additionalSpeed;
        }

        // Set speed
        carRecord.current[index].speed = Math.min(
          carSpeedMin + Math.random() * carSpeedRange,
          maxSpeed,
        );
        if (!isFrontLane) carRecord.current[index].speed *= -1;

        // Change car color
        const newUV = getRandomAtlasUV(atlasSize, isFrontLane);
        const currentIUV = nodes.car.geometry.attributes.iUv as iUv;
        currentIUV.array[index * 2] = newUV[0];
        currentIUV.array[index * 2 + 1] = newUV[1];
        currentIUV.needsUpdate = true;

        // Reset deploy time
        carRecord.current[index].deployTime = null;

        // Set next car to deploy
        let carAfterIndex = (index + 1) % carsPerLane;
        if (!isFrontLane) carAfterIndex += carsPerLane;
        const carAfter = carRecord.current[carAfterIndex];
        carAfter.deployTime =
          clock.elapsedTime + carDurationMin + Math.random() * carDurationRange;
        // Add extra time if the carAfter is still being deployed
        let extraTime = 0;
        if (carAfter.speed !== 0) {
          const extraDistance = Math.abs(
            carAfter.speed > 0
              ? travelDistFromOrigin - carAfter.carObject.position.x
              : -travelDistFromOrigin - carAfter.carObject.position.x,
          );
          extraTime = extraDistance / Math.abs(carAfter.speed);
        }
        carAfter.deployTime += extraTime;

        return true;
      }
      return false;
    };

    // Front lane
    for (let i = 0; i < carsPerLane; i++) {
      if (handleCarDeployment(i, true)) break;
    }
    // Back lane
    for (let i = carsPerLane; i < carsPerLane * 2; i++) {
      if (handleCarDeployment(i, false)) break;
    }
    carRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <group dispose={null}>
      <instancedMesh
        ref={carRef}
        args={[undefined, undefined, carsPerLane * 2]}
        geometry={nodes.car.geometry}
      >
        <meshBasicMaterial map={bakedCarAtlas} onBeforeCompile={modifyShader} />
      </instancedMesh>
    </group>
  );
}

useGLTF.preload('/models/car.glb');
useTexture.preload('/textures/bakedCarAtlas.jpg');
