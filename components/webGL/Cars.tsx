/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useRef, useEffect } from 'react';
import { useGLTF, useTexture } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame } from '@react-three/fiber';
import getRandomAtlasUV from './handlers/getRandomAtlasUV';

type GLTFResult = GLTF & {
  nodes: {
    car: THREE.Mesh;
  };
};

export default function Cars() {
  const { nodes } = useGLTF('/car.glb') as GLTFResult;
  const bakedCarAtlas = useTexture('/bakedCarAtlas.jpg');
  bakedCarAtlas.flipY = false;

  const atlasSize = 2;
  const texStep = 1 / atlasSize;

  /*
  / Modifying shader to use atlas
  */
  const modifyShader = (shader: THREE.Shader) => {
    shader.vertexShader = `
    	attribute vec2 iUv;
      varying vec2 instUv;
      ${shader.vertexShader}
    `.replace(
      `#include <begin_vertex>`,
      `#include <begin_vertex>
      	instUv = iUv;
      `,
    );
    shader.fragmentShader = `
    	varying vec2 instUv;
    	${shader.fragmentShader}
    `.replace(
      `#include <map_fragment>`,
      `
      #ifdef USE_MAP
        vec4 sampledDiffuseColor = texture2D( map, instUv + vUv * ${texStep} );

        diffuseColor *= sampledDiffuseColor;
      #endif
    `,
    );
  };

  /*
  / Animating cars
  */
  const carRef = useRef<THREE.InstancedMesh>(null!);
  const carsPerLane = 4;
  const carSpeedMin = 0.5;
  const carSpeedRange = 1;
  const carDurationMin = 2;
  const carDurationRange = 4;
  // Initialize car speeds as 0;
  const carRecord = useRef<
    { speed: number; deployTime: number | null; carObject: THREE.Object3D }[]
  >(new Array(carsPerLane * 2));

  useEffect(() => {
    for (let i = 0; i < carsPerLane * 2; i++) {
      carRecord.current[i] = {
        speed: 0,
        deployTime: null,
        carObject: new THREE.Object3D(),
      };
    }
    // Move first cars
    carRecord.current[0].speed = carSpeedMin + Math.random() * carSpeedRange;
    carRecord.current[carsPerLane].speed = -(
      carSpeedMin +
      Math.random() * carSpeedRange
    );
    carRecord.current[1].deployTime =
      carDurationMin + Math.random() * carDurationRange;
    carRecord.current[carsPerLane + 1].deployTime =
      carDurationMin + Math.random() * carDurationRange;

    const uvs = [];
    for (let i = 0; i < carsPerLane; i++) {
      const carObject = carRecord.current[i].carObject;
      carObject.position.set(-7, 0.04, 1.56);
      carObject.updateMatrix();
      uvs.push(...getRandomAtlasUV(atlasSize, true));
      carRef.current.setMatrixAt(i, carObject.matrix);
    }
    for (let i = carsPerLane; i < carsPerLane * 2; i++) {
      const carObject = carRecord.current[i].carObject;
      carObject.position.set(7, 0.04, 1.97);
      carObject.rotation.set(0, Math.PI, 0);
      carObject.updateMatrix();
      uvs.push(...getRandomAtlasUV(atlasSize, false));
      carRef.current.setMatrixAt(i, carObject.matrix);
    }
    carRef.current.instanceMatrix.needsUpdate = true;

    nodes.car.geometry.setAttribute(
      'iUv',
      new THREE.InstancedBufferAttribute(new Float32Array(uvs), 2),
    );
  }, []);

  useFrame(({ clock }, delta) => {
    // Move cars
    for (let i = 0; i < carsPerLane * 2; i++) {
      const carSpeed = carRecord.current[i].speed;
      if (carSpeed === 0) continue;
      const carObject = carRecord.current[i].carObject;
      carObject.position.x += carSpeed * delta;
      if (carObject.position.x > 7) {
        carObject.position.x = -7;
        carRecord.current[i].speed = 0;
      } else if (carObject.position.x < -7) {
        carObject.position.x = 7;
        carRecord.current[i].speed = 0;
      }
      carObject.updateMatrix();
      carRef.current.setMatrixAt(i, carObject.matrix);
    }

    // Deploy cars
    // Front lane
    for (let i = 0; i < carsPerLane; i++) {
      if (
        carRecord.current[i].deployTime &&
        clock.elapsedTime > carRecord.current[i].deployTime!
      ) {
        carRecord.current[i].speed =
          carSpeedMin + Math.random() * carSpeedRange;
        carRecord.current[i].deployTime = null;

        carRecord.current[(i + 1) % carsPerLane].deployTime =
          clock.elapsedTime + carDurationMin + Math.random() * carDurationRange;

        break;
      }
    }
    // Back lane
    for (let i = 0; i < carsPerLane; i++) {
      if (
        carRecord.current[i + carsPerLane].deployTime &&
        clock.elapsedTime > carRecord.current[i].deployTime!
      ) {
        carRecord.current[i + carsPerLane].speed = -(
          carSpeedMin +
          Math.random() * carSpeedRange
        );
        carRecord.current[i + carsPerLane].deployTime = null;

        carRecord.current[((i + 1) % carsPerLane) + carsPerLane].deployTime =
          clock.elapsedTime + carDurationMin + Math.random() * carDurationRange;
        break;
      }
    }
    carRef.current.instanceMatrix.needsUpdate = true;
  });

  return (
    <group dispose={null}>
      <instancedMesh
        ref={carRef}
        args={[undefined, undefined, carsPerLane * 2]}
        geometry={nodes.car.geometry}
        // position={[-5, 0.04, 1.56]}
      >
        <meshBasicMaterial map={bakedCarAtlas} onBeforeCompile={modifyShader} />
      </instancedMesh>
    </group>
  );
}

useGLTF.preload('/car.glb');
